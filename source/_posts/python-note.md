---
title: python-note
date: 2020-03-12 20:49:23
tags: [python,快查]
categories: computer
updated: 2020-03-16 

---
<blockquote class="blockquote-center">Life is short, you need Python!</blockquote>
<!--more-->
<!--
    updated:
    2020-03-16 89-94p
    2020-03-12
-->

[视频地址](https://www.bilibili.com/video/av29837702?p=1)  

## 第一章 计算机基础知识

### 课程介绍
    Python基础视频教程  
    李立超讲的
    学习方法：认真听，多敲代码  

### 计算机是什么  
计算的机器。我佛了

### 计算机的组成  
硬件与软件。  
    软件又分为**系统软件**与**应用软件**。

### 计算机的使用方式  
通过软件来操作计算机。
    并不是所有功能和数据都对用户开放
    需要调用软件提供的接口来操作计算机

用户界面分为两种：
    **GUI**图形交互界面
    **TUI**文本交互界面

### windows的命令行  
命令行就是文本交互界面
    任何计算机的操作系统都包含命令行（windows、linux、macOS）

命令行的不同名字：
    命令行，命令行窗口、DOS窗口、命令提示符、CMD窗口、Shell、终端、Terminal

命令行结构：
- 版本及版权声明（没卵用）
- 命令提示符
  - 可以通过`x:`来切换盘符
  - `cd`来切换路径
  - >后面输入指令

### 环境变量  
环境变量指的是操作系统里的一些变量，来对计算机进行配置（主要是来配置一些路径）

### path环境变量  
变量中保存的是一个一个的路径。能在任意路径访问到那些path中的路径中的文件。

### 进制  
- 十进制
- 二进制
- 八进制
- 十六进制

bit 位
byte 字节 = 8 bit


### 文本文件和字符集  
- 纯文本
  - 只能保存单一的文本，无法保存与文本无关的东西
- 富文本
  - 可以保存文本以外的内容，如样式、图片等

字符转换为二进制，称为解码
二进制转换为字符，称为编码

常见的字符集：
- ASC II
  - 美国人编码，7位对美国常用的字符进行编码
- ISO-8859-1
  - 欧洲人编码，8位，256个字符
- GB2312
  - 中国
- GBK
  - 中国
- Unicode
  - 万国码，包含了世界上几乎所有语言符号
- UTF-8
  - Unicode的一种，变长的字符集，1-5字节

### Sublime Text 3  
    俺不用，俺用VScode

## 第二章 Python入门

### 什么是计算机语言
计算机用的语言
- 机器语言
  - 0，1
- 汇编语言
  - 直接写符号，符号转机器码的过程称作汇编
  - 机器码转化为符号称作反汇编
  - 兼容性比较差
- 高级语言
  - 与硬件关系没那么紧密了
  - 可以在不同的硬件系统中执行
  - 学习成本低很多，现在我们知道的语言基本都是高级语言

### 编译型语言与解释型语言
- 编译型语言
  - 例如C
  - 代码执行前，源码 -> 编译 -> 机器码
  - 特点
    - 执行速度快
    - 跨平台性比较差
- 解释型语言
  - Python, js
  - 源码 -> 解释器 -> 解释执行

### Python介绍
Python是解释型语言，Guido Van Rossum 于1991年设计pyhton

Python用途：
- WEB
- 爬虫
- 科学计算
- 自动化运维
- 大数据方向（数据清洗
- 云计算
- 游戏
- 人工智能

### Python开发环境的搭建
安装Python的解释器
Python的解释器分类
- CPython
  - C语言编写的，官方出的
- PyPy
  - Python编写的Python解释器
- IronPython
  - 用.net编写的Python解释器
- Jython
  - 用Java编写的Python解释器

### Python的交互界面
你输入一行，它执行一行，但不太适合日常开发，只适合学习和测试。

### 几个概念
- 表达式
  - 类似数学表达式，不产生任何影响
- 语句
  - 完成某种功能，交互模式中不一定输出语句的结果，例如 a = 10
- 程序
  - 由一条条语句和表达式构成
- 函数
  - 一种语句，完成某种特定功能
  - 函数分类
    - 内置函数：Python解释器提供的，可以直接使用
    - 自定义函数：程序员自助创建的函数
  - 函数两要素
    - 参数-多个参数用,隔开
    - 返回值


### 基本语法
1. Python中严格区分大小写
2. 每一行就是一条语句，每一条语句以换行符结尾
3. Python中每条语句不要过长（规范建议每行不要超过80个字符）
4. Python语句可以分多行编写，语句后边以\反斜杠结尾
5. Python是锁进严格的语句，不要随意缩进
6. #后可以写注释，习惯上#后跟着一个空格

### 字面量、变量和标识符
- 字面量
  - 表示一个值，你看到是啥，它就是啥，例如：1，2，3
- 变量
  - 可以用来保存字面量
  - 它保存的字面量是可变的
  - Python中使用变量不需要声明，直接使用即可，但不能使用没赋值过的变量,不然会报错
    - NameError: name 'a' is not defined
  - 动态类型，可以为一个变量赋任意类型的值
- 标识符
  - Python中可以自主命名的东西
    - 变量名、函数名、类名
  - 标识符可以包含字母数字_，但是不能使用数字开头
  - 标识符不能是Python中的关键字和保留字
  - 不建议使用函数名作为标识符，比如print
- 命名规范
  - 下划线命名法
    - 所有字母小写，单词之间用_分割
  - 帕斯卡命名法（大驼峰命名法
    - 首字母大写，每个单词首字母大写，其余小写

开发时，一般很少使用字面量，经常是把字面量保存在变量里，然后使用变量

### 数据类型
- 数值分为三种
  - 整数
    - 大小无限制，可以任意大
    - 如果数字长度过大，可用_分隔，例如123_456_789
    - 十进制不能以0开头
    - 二进制0b开头
    - 八进制0o开头
    - 十六进制0x开头
    - 打印肯定以十进制打印
  - 浮点数（小数）
  - 复数
- 字符串
  - 表示一段文本信息，是程序中使用最多的数据类型
  - 字符串要用引号引起来可以是单引号，可以是双引号，但不能混着用
  - 相同的引号间不能嵌套
    - 非想里面用引号，可以在引号钱加反斜杠\表示转义字符
    - \'
    - \"
    - \t 制表符
    - \n 表示换行符
    - \\ 反斜杠
    - \uxxxx 表示unicode编码
  - 长字符串
    - 使用三重引号表示长字符串
    - 可以换行并且保留格式
  - 字符串中可以用%s %d %f等表示占位符
    - %3s，长度为3的字符串
    - %3.5s，长度为3-5的字符串
  - 格式化字符串
    - c = f"hello {a} {b}"
      - 其中{a}{b}的ab可以直接是变量
- 布尔值
  - True
  - False
- 空值
  - None，表示不存在


### 类型检查
type函数
```
c = type(123)
print(c)
```

### 对象（object）
- Python 是一门面向对象的语言
- 一切皆对象
- 对象就是内存中专门用来存储指定数据的一块区域
- 对象就是一个容器，专门用来存储数据
- 像我们之前学习的 数值、字符串啥的都是对象
- 对象的结构
  - id
    - 表示对象的唯一性
    - 可以通过id()函数来查看对象的id
    - id由解释器生成的
    - CPython中，id就是对象的内存地址
  - type
    - 类型表示当前对象所属类型
    - Python是一门强类型的语言，一旦创建，类型无法改变
    - type()函数可以查看类型
  - value
    - 对有些对象，值可以改变，叫可变对象
    - 不可变对象，常量


### 变量与对象
- 对象并没有直接存储到变量中
- Python中变量更像是给对象起了个别名，变量存的是对象的id

### 类型转换
- 所谓类型转换，就是将一个类型的对象转换为其他对象
- 类型转换不是改变对象本身的类型，而是根据当前对象的值，创建一个新的对象
- 四个函数
  - int()
    - 布尔值变0，1
    - 浮点数取整
    - 合法的整数字符串直接变int,小数也不行
    - None转不了
  - float()
    - 跟int()规则差不多，只不过变成了小数
  - str()
    - 布尔变True,False
    - 整数浮点数变数字的字符串
  - bool()
    - 表示空性的都是False，其他都是True
    - None是False
  - 不会对原来的变量产生影响，而是根据其值转换为指定类型然后把所得返回

### 运算符
- 可以对对一个值或者多个值进行运算或者各种操作
- 种类
  - 算数运算符
    - 除法总会返回一个浮点数
    - +
    - -
    - *
    - /
    - //地板除，结果只会保留一个整数
    - **幂运算，可用来开方
    - %取模
  - 比较运算符(关系运算符)
    - 不支持不同类型比较
    - 字符串比的是编码大小，且是逐位比较，前一位一样才会比后面
    - <,>,<=,>=,==,!=
    - 返回值是True,False
    - is , is not 比较对象的id
  - 赋值运算符
    - =
  - 逻辑运算符
    - not
    - and
    - or
    - 且或运算看完第一个后如果有结果就不会看第二个
    - 非布尔值的逻辑运算
      - 如果第一个值符合，就返回第一个值，否则返回第二个值
  - 条件运算符（三元运算符）
    - 语句1 if 条件表达式 else 语句3
  - 等等

### 运算符的优先级
自己找表然后补上来，不用背，不记得的时候用括号就完事了

## 第三章 流程控制语句
- Python代码是自上而下执行的  
- 通过流程控制可以改变程序的执行顺序，也能让指定代码反复执行多次

### 条件判断语句
- if语句
- 一般指管到后面那条语句
- 如果想要控制多条语句，可以用代码块
  - if xxx: 
  - 代码块要缩进

### 循环语句
- while循环
  - while 条件表达式:
    - 代码
    - 代码
  - else:
    - 代码
    - 代码

### break 和 continue
- break
  - 立即退出循环，并且不搞else
- continue
  - 跳过当次循环
- 都只跳过离他最近的循环
- pass
  - 先过，占个位置，循环功能不确定的时候可以先写

## 第四章 序列

### 列表(list)
- []
  - 列表是Python中的一个对象
  - 其他对象只能存单一数值，列表可以存多个
  - 可以用索引(index)来获取列表中的元素，是从0开始的整数，类似序号，可以是负数，倒数
- len()获取列表长度
- 切片[起始位:结束位置]
  - 结束位置不包括它本身
  - 不写起始位，则从头开始
  - 不写结束位，则到尾才结束
- 带步长的切片
  - [起始位置:结束位置:步长]
  - 负数的步长代表倒着取
- **下面是通用操作**
- 加+与乘*
  - +，把两个列表拼接为一个列表
  - *，把指定列表重复n次
- in 与not in
  - 在的话 in 返回True
- min() 与 max()
- 两个方法(method)
  - 方法即与对象关系紧密的函数
  - s.index()
    - 获取指定元素在列表中第一次的位置(index)，不存在的话会报错
    - 例如:s.index("ok",3)
    - 第二个参数表示从某个位置开始找，第三个参数表示查找的结束位置 
  

### 序列(sequence)
- Python中一种基本的数据结构
- 具有索引(index)
- 种类
  - 可变序列
    - 列表(list) 
  - 不可变序列
    - 字符串(str)
    - 元组(tuple)
- 修改-可变序列
  1. 索引单个修改
  2. 切片多个赋值
    - 切片赋值时必须赋一个序列给它，否则报错
  3. a[3:3]=
    - 在3的位置插入元素
  4. del a[:]
  5. a[:] = []



a.append(s)
把s元素添加到最后

a.insert(i,s)
把s插入到a的i位置

a.extend(t)
把序列t加到序列a的末尾

a.clear()
清空序列，用了后序列a就变成[]

a.pop(i)
删除索引为i的元素，并返回它的值
不填参数的话默认删除最后一个元素

a.remove(s)
删除指定元素s，如果有多个s，则删掉遇上的第一个s

a.reverse()
用来反转列表，颠倒顺序

a.sort()
对列表中的元素进行排序，字母、数字顺序，默认升序，如果想要降序排列`(reverse = True)`

### 遍历列表

可以用 while 循环

或者用 for 循环：
```
for 变量 in 序列:
  代码块
  代码块
```
每执行一次，就会把元素赋值给变量

### EMS练习(employee manager system) 员工管理系统
- 命令行版本的员工管理系统
- 功能
  - 查询
  - 添加
  - 删除
  - 退出

### range()
- range()是一个函数，可以用来生成一个自然数的序列
- 三个参数，用逗号隔开
  - 起始位置（可以省略，默认为0）
  - 结束位置
  - 步长（可以省略，默认为1）
- for 可以识别 range()，配合着执行指定次数的循环 

### tuple（元组）
- 元祖是一个不可变的序列
- 操作方式基本和列表一致
- 可以把它当成一个不可变的列表
- 当我们希望数据不会改变时，就使用元祖，其余情况都使用列表
- 使用()来创建元祖-列表则是[]
- 当元祖不是空元祖或者单元素的时候，可以省略括号，例如 1，2，3，5
- a,b,c,d = (1,3,4,7)
  - 叫做元祖的结构
  - a,b,c,d 都会被赋值
- a , b , *c, d = (1,2,3,4,5,6)
  - c会变成一个列表 [3,4,5]
  - 加星号会获取剩余所有能获取的元素
  - 不能同时有两个*
- 以上操作叫做解包（结构）
- 序列都能解包

### 可变对象
- 每个对象中都保存了三个数据：
  - id
  - type
  - value
- 列表是一个可变对象
  - a = [1,2,3]
    - a[0] = 10
      - 这种赋值方式改变了对象
    - a = [10,2,3]
      - 这种赋值方式没改变原对象，而是把a指向了另外一个对象
- 一般为变量赋值时，才把指向地改掉，不然都是修改对象的值

### ==/!= is/is not

- ==/!= 比较的是值相不相等
- is/is not 比较的是id相不相等

### 字典(dict)
- 字典属于一种新的数据结构，称为映射（mapping）
- 跟列表类似，都是存储对象的容器
- 字典查询数据的性能比列表好，每个元素都有唯一的一个名字，这个名字叫做键(key)
- 通过键值(key-value)可以快速找到那个元素，每个键值我们称其为一项（item）
- 使用{}来创建字典
- {key:value,key:value,key:value}
- 字典的值可以是任意对象
- 键只能是任意的不可变对象，且不能重复，一般使用字符串
- 字典写的时候可以换行
- d = {'name':'孙悟空','age':18}
- d['name'] 可以得到'孙悟空'
- 如果使用了列表中不存在的键，则会报错


#### 创建字典
1. 直接给变量赋值
2. d = dict(name='孙悟空',age=18,gender='男')
3. 也能把一个有双值子序列的列表转化为字典，假设它是a
   - b = dict(a)
- len()
  - 获得字典中键值对的个数
- in 与not in
  - 检查字典中是否包含指定的键
- 获取键值
  - d['name']
    - 但是如果键不存在，则会跑出一个keyerror
  - d.get('name'[,default])
    - 键不存在的话，返回None
    - 也可以指定一个默认值来作为第二个参数，这样取不到值的时候会返回默认值

#### 修改字典
- d[key] = 
  - 如果key存在，就修改值
  - 如果没有那个key的话会增加一个key-value
- setdefault(key[,value])
  - 如果key存在，则返回key的值
  - 如果key不存在，则添加一堆key-value
- d.update([other])
  - 把other字典中的东西全都合进d中
  - 如果重复，则替换掉

#### 删除字典
- del d[key]
  - 可以把
- d.popitem()
  - 可以随机删除字典中的一个键值对，一般都是最后一个键值对
  - 会返回一对key-value的二元素的元组
  - 删空字典的时候会报错
- d.pop(key[,default])
  - 会返回被删除的value
  - 如果删除不存在的key，会报错
  - 如果指定了默认值，就不会报错，会返回默认值
- d.clear()
  - 删除字典中的所有项
- d.copy
  - 浅复制，字典中的字典（可变对象）还是相互联系的，也就是修改一个会影响另一个
  - d2=d.copy()
  - d跟d2一样，但是有两个对象，修改一个对象不会影响另一个对象

#### 遍历字典
- d.keys()
  - 返回一个序列，序列中会保存字典中所有的键
  - `for k in d.keys():`
  - `print(k,d[k])
- values()
  - `for v in d.values():`
  - `print(v)`
- items
  - 返回一个双值序列
  - `for k,v in d.items:`
  - `print(k, '=' ,v)`


### 集合
- 集合和列表非常相似
- 不同
  1. 集合中只能存储**不可变**对象
  2. 集合中存储的对象是无序的（不是按照元素的插入顺序保存）
  3. 集合中不能出现重复的元素
- 可以使用{}来创建集合
- s = set()
  - 创建空集合
  - 可以通过set()将序列和字典转换为集合
  - 将字典转换为集合的时候，只会包含字典中的键
- 没办法用s[0]来索引集合
- in 和 not in可以用来检查集合中的元素
- len()可以
- s.add(10)
  - 向s中加元素
- s.update(s2)
  - 把s2中的元素加到s里
  - s2可以是序列或者字典，字典的话只会加key
- s.pop()
  - 随机删除一个集合中的元素
  - 返回被删除的元素
- s.remove()
  - 删除指定元素
- s.clear()
  - 让他变成空集
- s.copy
  - 浅复制

### 集合的运算
- 交集运算
  - s1 & s2
  - 不会改变s1与s2，而是返回它们的交集
- 并集运算
  - s1 | s2
- 差集
  - s1 - s2
  - 得到 只在s1中存在，但不在s2中的元素的集合
- 亦或集
  - s1 ^ s2
  - 得到：并集 - 交集
- <=
  - 检查一个集合是否是另一个集合的子集
  - 返回True 或者 False
- <
  - 检查真子集
- >
- >=

## 第五章 函数

### 函数简介（function）
- 函数也是一个对象  
- 对象是内存中专门用来存储数据的一块区域
- 函数可以用来暴怒一些可执行的代码
  ```
  def 函数名([形参1,形参2,形参3]):
    代码块
  ```
- 函数中保存的代码不会立即执行，需要调用才会执行
- 调用函数:
  - `函数对象()`
- 函数名需要符合标识符的规范

### 函数的参数
- 形式参数
  - 定义函数时，可以在函数名后的()里定义数量不等的形式参数，形参之间用,隔开
  - 相当于在函数里声明了变量，但是没有赋值
  - 可以为参数指定默认值
    - 例如：
    `def time(a = 10,b)`
    - 如果传了参数，那么以传了的为准，如果没传，以10为准
- 实际参数（实参）
  - 调用函数时需要传递实参
  - 实参的传递方式
    - 位置参数：第一个实参传给第一个形参，第二个。。。
    - 关键字参数：可以不按顺序传递，可以根据参数名去传递
    例如：
    time(b = 10, a = 15)
    - **混合使用位参和关键字参数时，必须将位置参数写到前面**
    - 实参可以是任意类型，比如整数、列表、元组、函数。。。
- 一般在函数内部操作不改变实际参数的值，但如果形参是一个对象，那可能会改变所有指向该对象的变量，例如列表a[1]
  - 避免这种情况可以使用副本，例如`function(c.copy())`
- 不定长参数（装包）
  - 例如求任意个数字的和
    - 遍历元组，并将元组中的数进行累加
  - 在定义函数时，可以在形参前面加上一个*，那么这个形参将会获得剩下所有的实参（数据类型：元组），这时无参数也不会报错
  - 带\*的形参只能有一个，可以不写最后，但是带\*的参数后面的参数，必须以关键字参数来传递
  - 如果在形参的开头直接写一个`*,`，那么要求所有的参数都以关键字参数的形式传递
  - \*形参只能接受位置参数，不能接受关键字参数
  - \*\*形参可以接受其他的关键字参数，并将那些参数统一保存到一个字典中，\*\*形参必须写在所有参数最后
- 参数的解包
  - 传递实参时，也能在序列类型的参数添加\*，这样他会自动将序列中的元素依次作为参数传递
  - 这里要求序列中的元素哥苏跟形参的个数一致

### 返回值
- return xxx
- xxx可以是任意对象
- 不写xxx或者不写return的话，返回None
- return后面的代码都不会执行
- fn与fn()有区别，一个是函数，一个是返回值

### help()
- Python中的内置函数，可以查询函数用法
- 可以给自己的函数写说明
- 在行数第一行写一个字符串或者字符块就可以了
- 形参后面例如`a:bool`之类的可以描述期待的参数类型，但是不具有强制性

### 作用域
- 全局作用域
  - 在程序执行时创建，在执行结束的时候销毁
- 函数作用域
  - 函数每调用一次就会产生一个新的函数作用域
  - 在函数作用域中定义的变量，都是局部变量，它只能在函数内部被访问
    - 嵌套函数的内部函数可以访问外部函数的变量
- 使用变量的时候，优先找当前作用域中的变量，如果没有则去上一级作用域中找，如此往复，如果直到全局作用域中都没有则会报错`NameπError..............` 
- 在函数中为变量赋值时，默认是为局部变量赋值
- 如果想在函数内部修改全局变量，则需要事先用一行声明global关键字，例如`global a`

### 命名空间（namespace）
- 命名空间值得是变量存储的位置，每一个变量都需要存储到指定的命名空间当中
- 每一个作用域都会有一个与它对应的命名空间
- 全局命名空间保存全局变量，函数命名空间用来保存函数中的变量
- 明明空间实际上就是一个字典，专门用来存储变量的字典，向字典中添加key-value相当于添加一个变量，但不建议这么做
- locals()
  - 获取当前作用域的命名空间
- globals()
  - 获取全局的命名空间

### 递归
- 我调用我自己
- 递归是一种解决问题的方式，将大问题解决为小问题，例如求阶乘
- 两个条件
  1. 基线条件
    - 满足的话就不递归了
  2. 递归条件
    - 将问题继续分解的条件
- 递归跟循环类似
  - 循环编写起来容易，阅读起来稍难
  - 递归编写起来稍难，阅读起来容易

### 函数式编程
- Python中函数是一等对象，一般一等对象有以下特点
  1. 对象是在运行中创建的
  2. 能复制给变量或作为数据结构中的元素
  3. 能作为参数传递
  4. 能作为返回值返回
- 高阶函数
  - 至少符合以下两点之一
    1. 接收一个或者多个函数作为参数
    2. 将函数作为返回值返回
  - 当我们把函数作为参数的时候，实际上就是传了一段代码进函数
- filter()
  - 参数：
  1. 函数，根据该函数来过滤序列（可迭代的结构）
  2. 需要过滤的序列（可迭代的结构）
  - 返回值：过滤后的新序列（可迭代的结构）
- 匿名函数（lambda函数表达式）语法糖
  - 专门用来创建一些简单的函数，是函数创建的又一种方式
  - `lambda 参数列表 : 返回值`
  - 可以将匿名函数赋值给一个变量（但一般不这么用）
  - 一般作为参数使用，其他地方一般不用
- map()
  - 该函数可以对可迭代对象中的所有元素做指定的操作，然后将其添加到一个新的对象中返回
  - 一参数是函数
  - 二参数是要操作的对象
- sort()
  - 该方法可以接受一个关键字参数key，它是一个函数，sort会对列表中每个元素调用key，然后根据key的返回值排大小
- sorted()
  - 该函数用法与sort基本一致，但是sorted可以对任意的序列进行排序，并且使用sorted不会影响原来的对象，而是返回一个新对象
- 另一类高阶函数，返回一个函数的高阶函数-闭包
  - 返回的函数是在函数里面创建的，所以它可以访问到fn内部的变量，并且在全局调用的时候也能通过它访问到函数里面的数据，可以用来藏私有数据
  - 闭包条件：
    1. 函数嵌套
    2. 将内部函数作为返回值返回
    3. 内部函数必须要使用到外部函数的变量

#### 装饰器
- OCP（开闭原则）
  - 只能拓展程序，不能修改程序
- 不修改原函数的情况下，来对函数进行扩展
  - 把函数套进一个新函数，跟html的伪类before与after差不多
- 上面的方法还是好麻烦，所以可以创建一个函数，功能是为其他函数添加开头和结尾
  - 用\*args与\*\*kwargs来接收和传递参数
```
那个函数如果命名为begin_end
def一个函数前一行加：
@begin_end
就可以加装饰器了，可以加好几个装饰器
```
## 第六章 对象（Object）

### 什么是对象？
- 对象是内存中专门用来存储数据的一块区域
- 对象中可以存放各种数据（数字、布尔值、代码）
- 三部分组成
  1. 对象的标识（id）
  2. 对象的类型（type）
  3. 对象的值（value）

### 面向对象（oop）

- Python是一门面向对象的编程语言
- 所有操作都是通过对象来进行的
- 面向过程的编程的语言
  - 将程序的逻辑分解为一个一个的步骤，通过对步骤的抽象，来完成程序，符合人类思维
  - 例子：
    - 孩子上学
      1. 👩起床
      2. 👩洗漱
      3. 👩做早餐
      4. 叫👦起床
      5. 👦洗漱
      6. 👦吃🥣
      7. 👦背🎒去🏫
  - 这种方式往往只能适用于一个功能，如果要实现别的功能，哪怕差别小，也往往要重新编写代码，可复用性低
- 面向对象的编程语言
  - 对于面向对象的语言，一切都是对象
  - 例子
    - 孩他妈起床叫孩子上学
  - 面向对象的编程思想，将所有功能统一保存到对应的对象即可
  - 容易阅读，并且易于维护
- 面向对象的思想
  1. 找对象
  2. 搞对象

### 类（class）
- 我们目前所学习的对象都是Python内置的对象
- 但是内置对象并不能满足所有的需求，所以我们在开发中经常需要定义一些对象
- 类，相当于一个图纸，在程序中我们需要根据类来创建对象
- 也成对象是类的实例
- 如果多个对象是通过一个类创建的，我们称这些对象是一类对象
- int() float() bool() str() list() dict()。。。这些都是类
- 我们自定义的类都要使用大写字母命名，使用大驼峰命名法来命名

#### 定义一个简单的类
```
class 类名([父名]):
    代码块
```
`isinstance(10,int)`检查10是不是int的一个实例

#### 使用类创建一个对象的流程
```
mc = MyClass()
```
1. 创建一个变量mc
2. 在内存中创建一个新对象
3. 把对象的id赋值给变量mc

此时通过MyClass的类创造的对象都是空对象

可以向对象中添加变量，对象中的变量称为属性
```
mc.name = '孙悟空'
```

#### 类的定义
类和对象都是对现实生活中或程序的内容的抽象
- 所有的事物都有两部分构成：
  1. 数据（属性）
  2. 行为（方法）

类中可以定义变量和函数  
变量是公共变量，函数是方法

方法调用和函数调用区别：  
函数调用，想几个参数就几个参数，方法调用，默认传递一个参数，所以方法中至少定义一个形参

方法调用时，第一个参数由解析器自动传递，所以定义方法时要至少定义一个形参

调用一个对象的属性时，先找实例的，实例没有的话找类的，都没有就报错

#### 类的特殊方法（构造方法）

特殊方法都是以\_\_开头，\_\_结尾的方法

特殊方法不用我们自己调用（不用尝试自己调用）

特殊方法将会在特殊的时刻自动调用

\_\_init\_\_会在每次创建对象的时候立刻执行

#### 封装（面向对象三大特性之一，确保对象中的数据安全）
1. 类的属性不能乱改
2. 如果修改的话要合法，比如年龄不能是负数

- 将属性名改成外部不知道的名字，比如hidden_name
- 提供getter 和 setter
get_name(self)
set_name(self,name)
- 如果不希望外部访问，则去掉getter
- 如果不希望外部修改，则去掉setter
- 设置setter可以为数据验证

使用封装虽然增加了定义类的麻烦程度，但是确实增加了数据的安全性

- 可以为对象的属性使用双下划线\_\_开头，代表隐藏属性，只能在累的内部访问，无法通过对象访问
  - 其实隐藏属性是Python把名字改成了\_类名\_\_属性名

#### property装饰器
可以在getter的定义上面一行加`@property`，就可以在调用的时候不写括号()  
setter也有它的装饰器
```
@property
def name(self):                 #函数名要跟假属性名一致
    print("get执行了")
    return self._name

@name.setter                    #.setter前要跟假属性名一致
def name(self,name):            #函数名要跟假属性名一致
    print("setter调用了")
    self._name = name
```

### 继承（面向对象三大特征之一，保证了拓展性）
之前的类的功能，全部能用到新类，但是还要其他功能，就可以把之前的类继承来

子类继承父类的全部属性和方法，并且用isinstance()判断是否是父类的话也是。

创建类的时候，如果没写()或者()里啥都不写，那么默认它的父类是Object

#### issubclass(a,b)
检查a是不是b的子类

#### 重写
子类里有跟父类名字一样的方法的话，会优先调用子类的方法，这叫方法的重写（覆盖）
```python
def __init__(self,name,age):
    super().__init__(name)     # super()代表当前类的父类，且传的参数里不用填self
    self._age = age
```
#### 多重继承
类名.\_\_bases\_\_ 可以获取当前类的所有父类

多重继承，会使得子类拥有多个父类，并且继承他们的所有属性和方法，开发中应该尽量避免多重继承。

若多个父类中有重名的方法，前面的会覆盖后面的。

#### 多态（面向对象三大特征之一，确保了程序的灵活性）
```python
def say_hello(obj):
    print("你好 %s"%obj.name)
```
只要是个有name属性的对象它都能使用say_hello()这个函数，这就叫多态。

可以用某些特点来归类，比如会跑会游泳的都是一种东西，但是它们可能从属不同的类，但是它们却因为某些特点能干到一样的事。这就叫多态

### 本章前面总结
- 类
  - 类属性（公共的）
  - 实例属性（实例私有的）
  - 实例方法
    - 类定义中以self为第一个参数的方法
    - 可以用类或者实例调用
  - 类方法
    - 用@classmethod来修饰
    - 第一个参数是cls
    - 可以用类或者实例调用
  - 静态方法
    - 类定义中用@staticmethod来修饰的方法
    - 不用传任何参数
    - 可以用类或者实例调用

### 垃圾回收
没用的东西就是垃圾

没有引用的对象就是垃圾对象

Python有自动的垃圾回收机制

```python
def __del__(self):  # 特殊方法
```

### 特殊方法

用\_\_开头和结尾的方法，会在特殊时刻调用

#### __str__(self)
这个方法会在把对象转换为字符串时调用，例如打印对象。

#### __repr__(self)
指定在交互模式中输出的结果。

#### 比大小
##### __lt__(self,other)
小于

返回True或者False，自己定义大小比较的方法
##### __le__(self,other)
小于等于
##### __eq__(self,other)
等于
##### __ne__(self,other)
不等于
##### __gt__(self,other)
大于
##### __ge__(self,other)
大于等于

#### __bool__(self)
转换为bool值时返回的值

#### 其他

还有很多特殊方法，用的时候自己去文档里找

### 模块（module）

把一个完整的程序分解为一个一个小的模块

优点
1. 方便开发（多人
2. 方便维护（每个人/小组维护各自的功能
3. 模块可以复用

一个py文件就是一个模块，模块名要符合标识符的规范

引入模块方法：  
`import 模块名`  
或者
`import 模块名 as 模块别名`
- 这种方法可以引入同一个模块多次，但是模块的实例只会创建一个
- import 可以在程序的任意位置调用，但是一般情况下，import语句都会同意写在程序的开头
- __name__ 是每个模块都有的属性，可以得到模块的名字

#### 模块中的变量、函数与类
`模块名.变量`  
`函数名`  
`模块名.类名`

只引入模块的部分内容  
`from 模块名 import 变量,变量 (as 别名)`  

引入所有东西，不建议使用  
`from 模块名 import *`  

添加了\_的变量，只能在模块内部访问，通过*引入时，不会引入\_开头的变量

测试代码前面可以加`if __name__ == '__main':`

### 包 Package
包也是一个模块，当模块中代码过多时，或者一个模块需要被分解为多个模块时，这时就需要使用到包。

包可以把功能相关的模块都放在一起

模块是一个文件，包是一个文件夹  
`import 文件夹`

__pycache__是模块的缓存文件
- py代码执行前，需要被解析器先转换为机器码，然后再执行。
- 使用包（模块）时，也需要将模块的代码先转换为机器码然后执行
- 为了提高程序性能，Python会在编译过一次后，将代码保存到一个缓存文件中，下次再加载这个包（模块）时，就不用再搞了

### Python标准库

Python自带了标准库，提供很多功能，具体参考文档。

## 第七章 异常和文件

### 异常
程序在运行过程当中，不可避免的会出现一些错误，比如：
- 使用了没有赋值过的变量
- 使用了不存在的索引
- 除0

### 异常处理
当出现异常时，如果问题不大（不影响程序总体功能），不希望程序终止，可以使用以下语句来处理异常。
```python
# try语句
try:
    代码块（可能出现错误的语句）
except:
    代码块（出现错误后的处理方式）
else:
    代码块（没出错时要执行的语句）
finally:
    代码块（不管异不异常都会执行）
```
### 异常的传播

函数中如果用try处理了异常，则异常不会向上传播。  
如果没处理，则会向调用函数的地方传播，如果函数调用的地方处理了异常，则不再继续传播。如果到了全局作用域还没处理，则终止程序。

程序运行过程中出现异常后，所有的异常信息会被保存到有一个专门的异常对象中，异常传播时，实际上就是异常对象抛给了调用处。

比如ZeroDivisionError类的对象专门用来表示除0的异常，Python中有多个异常对象。

### 异常对象
如果except后不跟任何内容，则它会捕获到所有的异常，如果加个异常类型，则只会捕获到特定异常，例如：  
```python
except NameError:
except IndexError:
except Exception: # Exception是所有异常的父类
```



## 学习日志
 
｜20200228｜         1-5p   ｜
｜20200301｜        6-22p   ｜
｜20200302｜3:25am 23-30p   ｜
｜20200303-06:35am｜31-40p  ｜
｜20200304-00:05pm｜41-50p  ｜
｜20200305-01:57pm｜51-62p  ｜
｜20200306-07:11pm｜63-71p  ｜
｜20200313-02:34am｜72-80p  ｜
｜20200314-02:34am｜81-85p  ｜
｜20200315-05:33am｜86-88p  ｜
｜20200316-01:33am｜89-94p  ｜
｜20200317-00:00am｜95-100p ｜
｜20200318-11:38am｜101-110p｜
｜20200320-00:35am｜111-120p｜


下次：  
https://www.bilibili.com/video/av29837702?p=121